package output

import (
	"encoding/json"
	"fmt"
	"io"
	"strings"
	"time"

	"github.com/SimonRichardson/betwixt/pkg/entry"
)

const autoGeneratedTemplate = `
The following was automatically generated via [Project Ultra](https://github.com/simonrichardson/betwixt).
Date generated on: %s
`

// Options define certain setup values for rendering markdown
type Options struct {
	Header    string
	Optionals bool
}

// NewApiaryOptions make new Options for the Apiary format
func NewApiaryOptions(name string) Options {
	return Options{
		Header:    fmt.Sprintf("FORMAT: 1A\n# %s Blueprint\n", name),
		Optionals: true,
	}
}

// Markdown renders a markdown document with a writer and some Options for
// rendering
type Markdown struct {
	w       io.WriteCloser
	options Options
}

// NewMarkdown creates a Markdown with the correct dependencies
func NewMarkdown(w io.WriteCloser, options Options) *Markdown {
	return &Markdown{w, options}
}

// Output takes a slice of documents and generates a markdown document from them
func (o Markdown) Output(docs []entry.Document) error {
	if len(o.options.Header) > 0 {
		fmt.Fprintf(o.w, "%s\n", o.options.Header)
	}

	fmt.Fprintf(o.w, autoGeneratedTemplate, time.Now().Format(time.RFC3339))

	for _, v := range docs {
		fmt.Fprintf(o.w, "# %s %s\n\n", v.Method.String(), v.URL.String())
		fmt.Fprintf(o.w, "+ Request\n")

		if v.Params.Len() > 0 {
			fmt.Fprintf(o.w, "    + Parameters\n\n")
			writeParams(o.w, v.Params, o.options)
		}

		if v.ReqHeaders.Len() > 0 {
			fmt.Fprintf(o.w, "    + Headers\n\n")
			writeHeaders(o.w, v.ReqHeaders, o.options)
		}

		if union := v.ReqBody.String(); len(union) > 0 {
			fmt.Fprintf(o.w, "    + Body\n\n")
			switch getContentType(v.ReqHeaders) {
			case "application/json", "text/json":
				if err := writeBody(o.w, union); err != nil {
					return err
				}
			default:
				fmt.Fprintf(o.w, "            %s\n\n", union)
			}
		}

		fmt.Fprintf(o.w, "+ Response %d\n", v.Status.Union().Status)

		if v.RespHeaders.Len() > 0 {
			fmt.Fprintf(o.w, "    + Headers\n\n")
			writeHeaders(o.w, v.RespHeaders, o.options)
		}

		if union := v.RespBody.String(); len(union) > 0 {
			fmt.Fprintf(o.w, "    + Body\n\n")
			switch getContentType(v.RespHeaders) {
			case "application/json", "text/json":
				if err := writeBody(o.w, union); err != nil {
					return err
				}
			default:
				fmt.Fprintf(o.w, "            %s\n\n", union)
			}
		}
	}

	o.w.Close()

	return nil
}

func writeParams(w io.Writer, params *entry.Map, options Options) {
	params.Union().Values.Walk(func(k string, v interface{}) {
		fmt.Fprintf(w, "            %s ('%s')\n", k, entry.ToStrings(v).Join())
	})
	if options.Optionals {
		for _, v := range params.Difference() {
			v.Values.Walk(func(k string, v interface{}) {
				fmt.Fprintf(w, "            %s (optional, '%s')\n", k, entry.ToStrings(v).Join())
			})
		}
	}
	fmt.Fprintln(w, "")
}

func writeHeaders(w io.Writer, params *entry.Map, options Options) {
	params.Union().Values.Walk(func(k string, v interface{}) {
		fmt.Fprintf(w, "            %s: %s\n", k, entry.ToStrings(v).Join())
	})
	if options.Optionals {
		for _, v := range params.Difference() {
			v.Values.Walk(func(k string, v interface{}) {
				fmt.Fprintf(w, "            %s: %s (optional)\n", k, entry.ToStrings(v).Join())
			})
		}
	}
	fmt.Fprintln(w, "")
}

func getContentType(params *entry.Map) (res string) {
	params.Union().Values.Walk(func(k string, v interface{}) {
		if strings.ToLower(k) == "content-type" {
			res = entry.ToStrings(v).Join()
		}
	})
	return
}

func writeBody(w io.Writer, body string) error {
	var doc interface{}
	if err := json.Unmarshal([]byte(body), &doc); err != nil {
		return err
	}
	bytes, err := json.MarshalIndent(doc, "            ", "    ")
	if err != nil {
		return err
	}
	fmt.Fprintf(w, "            %s\n\n", bytes)
	return nil
}
